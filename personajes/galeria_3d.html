<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galería 3D de Personajes</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
        }
        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="character-info-overlay" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(40, 40, 50, 0.9); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 100; max-width: 400px; text-align: left;">
        <h2 id="info-name" style="margin-top: 0; border-bottom: 1px solid #666; padding-bottom: 10px;"></h2>
        <p id="info-bio" style="max-height: 150px; overflow-y: auto; margin-bottom: 10px;"></p>
        <p id="info-whisper" style="font-style: italic; background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px;"></p>
        <a id="info-link" href="#" target="_blank" style="color: #8af; text-decoration: none;">Leer más...</a>
        <button id="info-close-button" style="display: block; margin: 15px auto 0; padding: 8px 15px; background-color: #555; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>
    <canvas id="webgl-canvas"></canvas>
    <!-- Content will go here -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>

    <script type="module">
        // import * as THREE from 'three'; // THREE should be global from the script above
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2639); // Dark Sapphire Blue
        scene.fog = new THREE.Fog(0x1a2639, 5, 25);    // Matching fog

        // Canvas
        const canvas = document.getElementById('webgl-canvas');

        // Sizes
        const sizes = {
            width: window.innerWidth,
            height: window.innerHeight
        };

        // Camera
        const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000);
        camera.position.set(5, 3, 10); // Initial overview position
        scene.add(camera);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xaaaaee, 0.4); // Bluish tint, less intensity
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.6); // Pale Yellowish, intensity reduced to 0.6
        directionalLight.position.set(-5, 8, 3); // New position
        scene.add(directionalLight);

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true // Enable antialiasing
        });
        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Improve pixel ratio for sharper rendering

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 2;
        controls.maxDistance = 25; // Increased max distance
        // controls.maxPolarAngle = Math.PI / 2; // Prevent looking below the ground
        controls.update(); // Important after setting camera position if target is default

        // Post-processing
        let composer = new EffectComposer(renderer); // Initialize here
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);

        // Overlay DOM Elements
        const infoOverlay = document.getElementById('character-info-overlay');
        const infoName = document.getElementById('info-name');
        const infoBio = document.getElementById('info-bio');
        const infoWhisper = document.getElementById('info-whisper');
        const infoLink = document.getElementById('info-link');
        const infoCloseButton = document.getElementById('info-close-button');

        // Placeholder for character data
        let charactersData = [];

        async function loadCharacterData() {
            try {
                const response = await fetch('/assets/data/characters_enriched.json'); // Ensure this path is correct from the web server's root
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                charactersData = await response.json();
                console.log('Character data loaded:', charactersData);
                populateSceneWithCharacters(); // Call the new function here
            } catch (error) {
                console.error('Could not load character data:', error);
            }
        }

        function createSphereForCharacter(character, index) { // Added index parameter
            const charGeometry = new THREE.SphereGeometry(0.5, 32, 16);
            let colorValue = 0xcccccc;
            if (character.name && character.name.length >= 2) {
                const hashPart1 = character.name.charCodeAt(0).toString(16).padStart(2, '0');
                const hashPart2 = character.name.charCodeAt(1).toString(16).padStart(2, '0');
                const potentialColor = parseInt(`cc${hashPart1}${hashPart2}`, 16);
                if (!isNaN(potentialColor)) {
                    colorValue = potentialColor > 0xFFFFFF ? Math.random() * 0xffffff : potentialColor;
                } else { colorValue = Math.random() * 0xffffff; }
            } else { colorValue = Math.random() * 0xffffff; }

            const baseColor = new THREE.Color(colorValue);
            baseColor.lerp(new THREE.Color(0x555555), 0.5);

            const materialProperties = {
                color: baseColor,
                metalness: 0.1,
                roughness: 0.8
            };

            if (index === 1) { // Make the second character's sphere (index 1) a bit emissive
                materialProperties.emissive = baseColor;
                materialProperties.emissiveIntensity = 0.5;
            }

            const charMaterial = new THREE.MeshStandardMaterial(materialProperties);
            const charMesh = new THREE.Mesh(charGeometry, charMaterial);
            if (character.coordinates) {
                charMesh.position.set(character.coordinates.x || 0, character.coordinates.y || 0, character.coordinates.z || 0);
            } else {
                charMesh.position.set(Math.random() * 10 - 5, Math.random() * 2 - 1, Math.random() * 10 - 5);
            }
            charMesh.userData = character;
            charMesh.name = `character_${character.name}_sphere`; // Differentiate name
            scene.add(charMesh);
        }

        function populateSceneWithCharacters() {
            if (!charactersData || charactersData.length === 0) {
                console.log('No character data available to populate the scene.');
                return;
            }

            const gltfLoader = new GLTFLoader();

            // If the old single cube was added and needs removal:
            const oldCube = scene.getObjectByName("singleRotatingCube");
            if (oldCube) {
                scene.remove(oldCube);
                if (oldCube.geometry) oldCube.geometry.dispose();
                if (oldCube.material) oldCube.material.dispose();
            }

            charactersData.forEach((character, index) => {
                if (index === 0) { // Special handling for the first character to load a glTF model
                    gltfLoader.load(
                        'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf', // URL to a sample glTF model
                        (gltf) => {
                            const loadedModel = gltf.scene;
                            loadedModel.scale.set(0.2, 0.2, 0.2); // Scale down the model

                            if (character.coordinates) {
                                loadedModel.position.set(character.coordinates.x || 0, character.coordinates.y || 0, character.coordinates.z || 0);
                            } else {
                                loadedModel.position.set(Math.random() * 10 - 5, Math.random() * 2 - 1, Math.random() * 10 - 5);
                            }

                            loadedModel.userData = character;
                            loadedModel.name = `character_${character.name}_gltf`;

                            scene.add(loadedModel);
                            console.log(`Loaded glTF model for ${character.name}`);
                        },
                        undefined, // onProgress callback (optional)
                        (error) => {
                            console.error(`Error loading glTF model for ${character.name}:`, error);
                            createSphereForCharacter(character, 0); // Pass index 0 for the first character if it falls back
                        }
                    );
                } else { // For all other characters, create spheres as before
                    createSphereForCharacter(character, index); // Pass index
                }
            });

            console.log(`Populated scene with ${charactersData.length} characters (attempted).`);
        }

        loadCharacterData();

        // Simple Cube (Now handled by populateSceneWithCharacters or removed)
        // const geometry = new THREE.BoxGeometry(1, 1, 1);
        // const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.3, roughness: 0.4 }); // Green cube
        // const cube = new THREE.Mesh(geometry, material);
        // cube.name = "singleRotatingCube"; // Give it a name if we want to remove it later
        // scene.add(cube);

        function onDocumentMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1) for both components
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                if (intersectedObject.userData && intersectedObject.userData.name) { // Check if it has our character data
                    const charData = intersectedObject.userData;
                    infoName.textContent = charData.name;
                    infoBio.textContent = charData.bio_snippet || 'No biography available.';
                    infoWhisper.textContent = charData.whisper || '...';
                    if (charData.web_path) {
                        infoLink.href = charData.web_path;
                        infoLink.style.display = 'inline';
                    } else {
                        infoLink.style.display = 'none';
                    }
                    infoOverlay.style.display = 'block';
                }
            }
        }

        // Event Listeners
        window.addEventListener('click', onDocumentMouseClick, false);

        infoCloseButton.addEventListener('click', () => {
            infoOverlay.style.display = 'none';
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Update sizes
            sizes.width = window.innerWidth;
            sizes.height = window.innerHeight;

            // Update camera
            camera.aspect = sizes.width / sizes.height;
            camera.updateProjectionMatrix();

            // Update renderer
            renderer.setSize(sizes.width, sizes.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            composer.setSize(sizes.width, sizes.height);
            composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // Animation loop
        const animate = () => {
            // Update controls
            controls.update();

            // Rotate cube (The old single cube)
            /*
            const oldCube = scene.getObjectByName("singleRotatingCube");
            if (oldCube) {
                oldCube.rotation.x += 0.01;
                oldCube.rotation.y += 0.01;
            }
            */

            // Render scene using composer
            composer.render();

            // Call animate again on the next frame
            window.requestAnimationFrame(animate);
        };

        animate();
    </script>
</body>
</html>
