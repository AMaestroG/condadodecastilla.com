<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galería 3D de Personajes</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
        }
        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="character-info-overlay" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(40, 40, 50, 0.9); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); z-index: 100; max-width: 400px; text-align: left;">
        <h2 id="info-name" style="margin-top: 0; border-bottom: 1px solid #666; padding-bottom: 10px;"></h2>
        <p id="info-bio" style="max-height: 150px; overflow-y: auto; margin-bottom: 10px;"></p>
        <p id="info-whisper" style="font-style: italic; background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px;"></p>
        <a id="info-link" href="#" target="_blank" style="color: #8af; text-decoration: none;">Leer más...</a>
        <button id="info-close-button" style="display: block; margin: 15px auto 0; padding: 8px 15px; background-color: #555; color: white; border: none; border-radius: 5px; cursor: pointer;">Cerrar</button>
    </div>
    <canvas id="webgl-canvas"></canvas>
    <!-- Content will go here -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script>

    <script type="module">
        // import * as THREE from 'three'; // THREE should be global from the script above
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2639); // Dark Sapphire Blue
        scene.fog = new THREE.Fog(0x1a2639, 5, 25);    // Matching fog

        // Canvas
        const canvas = document.getElementById('webgl-canvas');

        // Sizes
        const sizes = {
            width: window.innerWidth,
            height: window.innerHeight
        };

        // Camera
        const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000);
        camera.position.set(5, 3, 10); // Initial overview position
        scene.add(camera);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xaaaaee, 0.4); // Bluish tint, less intensity
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.8); // Pale Yellowish, reduced intensity
        directionalLight.position.set(-5, 8, 3); // New position
        scene.add(directionalLight);

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true // Enable antialiasing
        });
        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Improve pixel ratio for sharper rendering

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 2;
        controls.maxDistance = 25; // Increased max distance
        // controls.maxPolarAngle = Math.PI / 2; // Prevent looking below the ground
        controls.update(); // Important after setting camera position if target is default

        // Overlay DOM Elements
        const infoOverlay = document.getElementById('character-info-overlay');
        const infoName = document.getElementById('info-name');
        const infoBio = document.getElementById('info-bio');
        const infoWhisper = document.getElementById('info-whisper');
        const infoLink = document.getElementById('info-link');
        const infoCloseButton = document.getElementById('info-close-button');

        // Placeholder for character data
        let charactersData = [];

        async function loadCharacterData() {
            try {
                const response = await fetch('/assets/data/characters_enriched.json'); // Ensure this path is correct from the web server's root
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                charactersData = await response.json();
                console.log('Character data loaded:', charactersData);
                populateSceneWithCharacters(); // Call the new function here
            } catch (error) {
                console.error('Could not load character data:', error);
            }
        }

        function populateSceneWithCharacters() {
            if (!charactersData || charactersData.length === 0) {
                console.log('No character data available to populate the scene.');
                return;
            }

            // Remove or comment out the old single cube code:
            /*
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.3, roughness: 0.4 }); // Green cube
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            */

            // If the cube was added previously and we want to remove it dynamically:
            const oldCube = scene.getObjectByName("singleRotatingCube"); // Assume we name it if we want to remove it
            if (oldCube) {
                scene.remove(oldCube);
                oldCube.geometry.dispose();
                oldCube.material.dispose();
            }


            charactersData.forEach(character => {
                const charGeometry = new THREE.SphereGeometry(0.5, 32, 16); // Radius 0.5

                // Simple color hash from name
                let colorValue = 0xcccccc; // Default grey
                if (character.name && character.name.length >= 2) {
                    const hashPart1 = character.name.charCodeAt(0).toString(16).padStart(2, '0');
                    const hashPart2 = character.name.charCodeAt(1).toString(16).padStart(2, '0');
                    // Ensure we don't get overly dark colors, mix with some base
                    const potentialColor = parseInt(`cc${hashPart1}${hashPart2}`, 16);
                    if (!isNaN(potentialColor)) {
                        colorValue = potentialColor > 0xFFFFFF ? Math.random() * 0xffffff : potentialColor;
                    } else {
                        colorValue = Math.random() * 0xffffff;
                    }
                } else {
                    colorValue = Math.random() * 0xffffff;
                }

                const baseColor = new THREE.Color(colorValue);
                baseColor.lerp(new THREE.Color(0x555555), 0.5); // Lerp towards grey to desaturate/darken

                const charMaterial = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    metalness: 0.1, // More matte
                    roughness: 0.8  // More matte
                });

                const charMesh = new THREE.Mesh(charGeometry, charMaterial);

                if (character.coordinates) {
                    charMesh.position.set(character.coordinates.x || 0, character.coordinates.y || 0, character.coordinates.z || 0);
                } else {
                    // Fallback position if coordinates are missing
                    charMesh.position.set(Math.random() * 10 - 5, Math.random() * 2 - 1, Math.random() * 10 - 5);
                }

                charMesh.userData = character; // Store all character data
                charMesh.name = `character_${character.name}`; // Assign a name for potential lookup
                scene.add(charMesh);
            });

            console.log(`Populated scene with ${charactersData.length} characters.`);
        }

        loadCharacterData();

        // Simple Cube (Now handled by populateSceneWithCharacters or removed)
        // const geometry = new THREE.BoxGeometry(1, 1, 1);
        // const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.3, roughness: 0.4 }); // Green cube
        // const cube = new THREE.Mesh(geometry, material);
        // cube.name = "singleRotatingCube"; // Give it a name if we want to remove it later
        // scene.add(cube);

        function onDocumentMouseClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1) for both components
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                if (intersectedObject.userData && intersectedObject.userData.name) { // Check if it has our character data
                    const charData = intersectedObject.userData;
                    infoName.textContent = charData.name;
                    infoBio.textContent = charData.bio_snippet || 'No biography available.';
                    infoWhisper.textContent = charData.whisper || '...';
                    if (charData.web_path) {
                        infoLink.href = charData.web_path;
                        infoLink.style.display = 'inline';
                    } else {
                        infoLink.style.display = 'none';
                    }
                    infoOverlay.style.display = 'block';
                }
            }
        }

        // Event Listeners
        window.addEventListener('click', onDocumentMouseClick, false);

        infoCloseButton.addEventListener('click', () => {
            infoOverlay.style.display = 'none';
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Update sizes
            sizes.width = window.innerWidth;
            sizes.height = window.innerHeight;

            // Update camera
            camera.aspect = sizes.width / sizes.height;
            camera.updateProjectionMatrix();

            // Update renderer
            renderer.setSize(sizes.width, sizes.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // Animation loop
        const animate = () => {
            // Update controls
            controls.update();

            // Rotate cube (The old single cube)
            /*
            const oldCube = scene.getObjectByName("singleRotatingCube");
            if (oldCube) {
                oldCube.rotation.x += 0.01;
                oldCube.rotation.y += 0.01;
            }
            */

            // Render scene
            renderer.render(scene, camera);

            // Call animate again on the next frame
            window.requestAnimationFrame(animate);
        };

        animate();
    </script>
</body>
</html>
